package com.malware.message;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.malware.controller.ProxyController;
import com.malware.datasvc.DataService;
import com.malware.datasvc.response.MagicResult;
import com.malware.datasvc.response.MalwareScanResult;
import java.io.IOException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jms.annotation.JmsListener;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;

@Component
public class MessageReceiver {
	
	private static final Logger LOG = LoggerFactory.getLogger(MessageReceiver.class);
	private static final String NSRL_ENGINE = "NSRL";
	private static final String METADEFENDER_ENGINE = "METADEFENDER";
	private static final String CUCKOO_ENGINE = "CUCKOO";

	@Value("${pam.signal.staticanalysis_nonarchive}")
	private String staticAnalysisNonArchiveSignal; //= "StaticNonArchiveAnalysisRcv";

	@Value("${pam.signal.dynamicanalysis}")
	private String dynamicAnalysisSignal; // = "DynamicAnalysisRcv";

	@Value("${pam.signal.staticanalysis_archive}")
	private String staticAnalysisArchiveSignal; // = "StaticArchiveAnalysisRcv";

	@Value("${pam.signal.nsrl_response}")
	private String nsrlSignal; // = "NsrlResultRcv";

	@Value("${pam.signal.magic}")
	private String magicSignal; // = "MagicResultRcv";

	private final ProxyController pamController;
	private final DataService dataService;
	private final ObjectMapper mapper;

	@Autowired
	public MessageReceiver(ProxyController pamController, DataService dataService, ObjectMapper mapper) {
		this.pamController = pamController;
		this.dataService = dataService;
		this.mapper = mapper;
	}

	/*
	 * Message receiver that listens to a queue
	 */
	@JmsListener(destination = "${spring.queue.name}")
    public void receiveMessage(Message submissionReq)
    {
        LOG.info("Received from submission queue: {}", submissionReq );
        
        pamController.startWorkflow(submissionReq.getMessage(), 0, "0", "0");
    }
	
	/*
	 * Message receiver that listens to a queue
	 */
	@JmsListener(destination = "${file.stage.queue}")
    public void receiveStagedMessage(Message submissionReq,
    								 @Header(name = "h_level", defaultValue="0") Integer filelevel,
    								 @Header(name = "h_sid", defaultValue="0") String sid,
    								 @Header(name = "h_submissionId", defaultValue="0") String submissionId) 
    {
        LOG.info("Received from staged queue: {} and header file level is {} and header sid is {} and submission id is {}", submissionReq, filelevel, sid, submissionId);
        
        pamController.startWorkflow(submissionReq.getMessage(), filelevel, sid, submissionId);
    }

	/**
	 * This will receive messages from the magic queue & forward them to the relevant process
	 * @param submissionReq the  input message
	 * @throws IOException if the message could not be parsed
	 */
	@JmsListener(destination = "${magic.queue.output}")
	public void handleMagicEvent(Message submissionReq) throws IOException {

		String body = submissionReq.getMessage();
		MagicResult result = dataService.processMagicResult(body);

		if (result != null) {
			LOG.info("Received process id lookup response. result = {}", result);
			pamController.triggerEvent(result.getProcessInstanceId(), magicSignal, body);
		} else {
			LOG.warn("Failed to lookup process instance id. body = {}", body);
		}

//		MagicMessage magic  = mapper.readValue(submissionReq.getMessage(), MagicMessage.class);
//
//		for (FileInfo info : magic.getFiles()) {
//			IdCacheLookup lookupResult = dataService.lookupProcessId(info.getSid(), info.getTid());
//			if (lookupResult == null) {
//				LOG.warn("Cache lookup failed for sid = {}, tid = {}. Received empty response", info.getSid(), info.getTid());
//			} else {
//				pamController.triggerEvent(lookupResult.getProcessInstanceId(), magicSignal, submissionReq.getMessage());
//			}
//		}

	}

	/**
	 * This will receive a message from the malware scan results queue and signal the relevant WAIT events.
	 */
	@JmsListener(destination = "${malware.scan.output}")
	public void receiveScanResultMessage(Message submissionReq) throws IOException {
		LOG.info("Received message from scan result: {}", submissionReq);

		MalwareScanResult result = dataService.processScanResult(submissionReq.getMessage());
		LOG.info("Received result from data service. {}", result);
		switch (result.getEngine()) {
			case NSRL_ENGINE:
				pamController.triggerEvent(result.getProcessInstanceId(), nsrlSignal, result.getBody());
				break;
			case METADEFENDER_ENGINE:
				pamController.triggerEvent(result.getProcessInstanceId(), staticAnalysisArchiveSignal, result.getBody());
				pamController.triggerEvent(result.getProcessInstanceId(), staticAnalysisNonArchiveSignal, result.getBody());
				break;
			case CUCKOO_ENGINE:
				pamController.triggerEvent(result.getProcessInstanceId(), dynamicAnalysisSignal, result.getBody());
		}
	}
}
