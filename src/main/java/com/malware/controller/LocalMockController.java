package com.malware.controller;

import java.util.List;
import java.util.UUID;
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.KieContainerResource;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LocalMockController {

	private static final Logger LOG = LoggerFactory.getLogger(LocalMockController.class);
	
	@Value("${spring.pam.url}")
	private String URL;
	
	@Value("${spring.pam.user}")
  	private String USER;

	@Value("${spring.pam.password}")
	private String PASSWORD;
	
	@Value("${spring.process.id}")
	private String processId;

/*	@Value("${dynamic.analysis.url}")
	private String dynamicAnalysisUrl;
	
	@Value("${static.analysis.url}")
	private String staticAnalysisUrl;*/
		
	@Value("${id.generator.url}")
	private String idGeneratorUrl;
	
/*	@Value("${dynamic.analysis.queue}")
	private String dynamicAnalysisQueue;
	
	@Value("${static.analysis.queue}")
	private String staticAnalysisQueue;

	@Value("${nsrl.analysis.queue}")
	private String nsrlAnalysisQueue;*/
	
	@Value("${amqphub.amqp10jms.remote-url}")
	private String brokerHost;
	
	@Value("${data.service.url}")
	private String dataServiceUrl;
	
	@Value("${submission.record.url}")
	private String submissionRecordUrl;
		
	@Value("${move.file.url}")
	private String moveFileUrl;
	
	@Value("${create.metadata.url}")
	private String createMetadataUrl;
		
/*	@Value("${create.metadata.request}")
	private String createMetadataReq;	*/

/*	@Value("${nsrl.lookup.url}")
	private String nsrlLookupUrl;*/
		
/*	@Value("${nsrl.lookup.request}")
	private String nsrlLookupReq;	*/

	@Value("${create.trecord.url}")
	private String createTransactionRecordUrl;
		
/*	@Value("${create.trecord.request}")
	private String createTransactionRecordReq;	*/
	
	@Value("${create.hash.url}")
	private String createHashUrl;
		
/*	@Value("${create.hash.request}")
	private String createHashReq;	*/

	@Value("${unzip.file.url}")
	private String unzipFileUrl;
		
/*	@Value("${unzip.file.request}")
	private String unzipFileReq;*/	
	
	@Value("${hash.seen.url}")
	private String hashSeenUrl;	
	
	private List <KieContainerResource> kieContainers;
	private KieContainerResource container;
	private String containerId;
	private ServiceResponse<Void> responseDispose;
	private ServiceResponse<KieContainerResource> createResponse;
	//private String processId;
	private Long processResult;
	  
	private final MarshallingFormat FORMAT = MarshallingFormat.JSON;

  	private KieServicesConfiguration conf;
  	private KieServicesClient kieServicesClient;

  	/*
  	 * Mock API below are for simplifying local testing 
  	 */
    @RequestMapping("/mock/generate_ids/1")
    @ResponseBody
	public String mockIdGen() {
    	String id = UUID.randomUUID().toString();
//    	String mockedResponse ="{\"ids\":[\"2022417230415.551783.021.000000\"]}";
		String mockedResponse ="{\"ids\":[\"" + id + "\"]}";
    	
		LOG.info("============= MOCKED REST API mock/generate_ids/1 triggered. Returning: " + mockedResponse);
		return (mockedResponse);
	}

    @RequestMapping("/mock/submissions")
    @ResponseBody
	public String mockFileSubmission() {
    	String mockedResponse = "{"
    			+"\"submission_id\": 890,"
					+"\"submission_type_cd\":\"Web\","
					+"\"description\":\"Baseketball\","
					+"\"traffic_light_protocol_cd\": \"Red\","
					+"\"sid\": \"23423424\","
					+"\"incident_id\": \"2-2\","
					+"\"ip\": \"123.56.89.1\","
					+" \"first_name\":\"Michael\","
					 +"\"last_name\":\"Jordan\","
					 +"\"phone_number\":\"123-456-7890\","
					 +"\"organization\":\"raytheon\","
					 +"\"email\":\"myemail@example.com\","
					 +"\"created_ts\": \"2020-04-17T14:54:25.12312Z\""
			+"}";
    	
    	
		LOG.info("============= MOCKED File Submission API mock/submission triggered. "); 
		return (mockedResponse);
	}

    @RequestMapping("/mock/move_files")
    @ResponseBody
	public String mockMoveFile() {
    	String mockedResponse ="{"
               + "\"errors\" :[ ],"
               + "\"file_info\" : ["
               + "{"
                     +"\"new_file_name\":\"23423423423\","
                     +"\"original_file_name\":\"virus_2.exe\","
                     +"\"path\":\"/mng/20200214\""
                  +"}"
               +"]}";
    		
		LOG.info("============= MOCKED File Mover API mock/move_files triggered. Returning: "+ mockedResponse);
		return (mockedResponse);
	}
    
    @RequestMapping("/mock/create_metadata")
    @ResponseBody
	public String mockCreateMetadata() {
    	String mockedResponse = "["
           +"{"
           +"\"error\": false,"
      +"\"message\": \"Metadata record is returned as result\","
      +"\"result\": {"
          +"\"file_metadata_id\": 402,"
          +"\"md5\": \"32343243\","
          +"\"sha256\": \"234234234234\","
          +"\"sha512\": \"131231232131\","
          +"\"ssdeep\": null,"
          +"\"created_ts\": \"2020-03-19T17:41:15Z\""
        +"}"
      +"}" 
      +"]";
    	
		LOG.info("============= MOCKED Create Metadata API mock/create_metadata triggered. Returning: " + mockedResponse);
		return (mockedResponse);
	}
 
    @RequestMapping("/mock/nsrl_lookup")
    @ResponseBody
	public String mockNsrlLookup() {
//    	String mockedResponse = "{"
//          +"\"2d1232432423423\":\"True\","
//          +"\"abc\":\"False\""
//        +"}";

		String mockedResponse = "{ \"errors\": [], \"hash_info\": [], \"messages\": [\"hash does not exist\"]}";
		LOG.info("============= MOCKED NSRL Lookup API mock/nsrl_lookup triggered. Returning: " + mockedResponse);
		return (mockedResponse);
	}
    
    @RequestMapping("/mock/create_trecord")
    @ResponseBody
	public String mockCreateTransactionRecord() {
    	String mockedResponse ="["
             + "{"
                  +"\"error\" : false,"
    +"\"message\": \"REcord updated\","
    +"\"result\": {"
         +"\"transaction_file_id\" : 472,"
         +"\"submission_id\": 392,"
         +"\"sid\": \"20200309150359.123.00000\","
         +"\"file_metadata_id\": null,"
         +"\"name\": \"test.exe\","
         +"\"location\": \"/mng/for_stix_mapping/\","
         +"\"size\": null,"
         +"\"magic_num\" : null,"
         +"\"verified_file_extension\": null,"
          +"\"tid\": \"202003091503.23423.23423\","
         +"\"original_name\": null,"
         +"\"pid\" : null,"
         +"\"level\": 0,"
         +"\"hash_exist_ind\": null,"
         +"\"nsrl_ind\": null,"
         +"\"malicious_archive_ind\": null,"
         +"\"created_ts\": \"2020--4-16T20:12:27.052728Z\""
       +"}"
       +"}"         
         +"]";
    	
		LOG.info("============= MOCKED Create Transaction Record API mock/crate_trecord triggered. Returning: " + mockedResponse);
		return (mockedResponse);
	}
    
    @RequestMapping("/mock/create_hash")
    @ResponseBody
	public String mockHashFile() {
    	String mockedResponse = "{\"results\": ["
			       +"{"
		            +"\"file_name\": \"virus_1.exe\","
		                 +" \"md5\": \"3242432234\","
		                  +"\"sha1\": \"23423423423\","
		                 +" \"sha256\": \"23424324\","
		                 +" \"sha512\": \"2342342342\","
		                  +"\"ssdeep\": \"3adfsdfasd\""
		        +"}"
		    +"]"
		    +"}";
    					
		LOG.info("============= MOCKED Create Hash API mock/create_hash triggered. Returning:  " + mockedResponse);
		return (mockedResponse);
	}

    @RequestMapping("/mock/unzip")
    @ResponseBody
	public String mockUnzip() {
    	String mockedResponse = "{"
                      + "\"errors\": [ ],"
                      + "\"file_info\": ["
                      + "{"
                            + "\"file_name\":\"virus_1.exe\","
                            + "\"path\": \"mng/tmp/unzip1\""
                       + "},"
                       + "{"
                       + "\"file_name\":\"virus_2.exe\","
                       + "\"path\": \"mng/tmp/unzip2\""
                       + "}"
                  + "]"
    	      + "}";
		LOG.info("============= MOCKED Unzip File API mock/unzip triggered. Returning: " + mockedResponse);
		return (mockedResponse);
	}

	@RequestMapping("/mock/get_analysis_report")
	@ResponseBody
	public String mockGetAnalysisReport() {

    	String mockedResponse = "{\n"
			+ "  \"results\": [\n"
			+ "    \"Record was added to the database successfully\"\n"
			+ "  ],\n"
			+ "  \"errors\": [],\n"
			+ "  \"messages\": []\n"
			+ "}";

		LOG.info("============= MOCKED Get analysis report triggered. Returning: " + mockedResponse);
		return mockedResponse;

	}
 
    @RequestMapping("/mock/hashseen")
    @ResponseBody
	public String mockHashSeen() {
    	String mockedResponse = "["
           +"{"
              +"\"error\": false,"
              +"\"message\": \"Record found\","
              +"\"result\": {"
              +"\"file_metadata_id\": 470,"
              +"\"md5\": \"12344565645\","
              +"\"sha1\": \"null\","
              +"\"sha256\": \"nnn\","
              +"\"sha512\": \"null\","
              +"\"ssdeep\": \"ssdeep\","
              +"\"created_ts\": \"2020-03031T20:02:47Z\""
          +"}"
        +"}"
       +"]";

		LOG.info("============= MOCKED Hash Seen API mock/hashseen triggered. Returning: " + mockedResponse);
		return (mockedResponse);
	}

	@PutMapping("/mock/transaction_file")
	@ResponseBody
	public String mockUpdateTransactionFile() {
    	String mockedResponse = "[{"
			+ "\"error\": false, "
			+ "\"message\": \"Test message\", "
			+ "\"result\": { "
			+ "  \"transaction_file_id\": \"100\"."
			+ "  \"tid\": \"1234.56.789\""
			+ "}"
			+ "]}";

		LOG.info("============= MOCKED Update transaction API mock/transaction_file triggered. Returning: " + mockedResponse);
		return mockedResponse;
	}
    
/*    @RequestMapping(value = "/dynamic/send", 
    		        method= RequestMethod.POST, 
    		        consumes = {"application/JSON"})
    @ResponseBody
    public String sendDynamicMessage(@RequestBody String payload) {
    	LOG.info("============= REST API /dynamic/send/ triggered. Received payload: " + payload);
    	producer.sendMessage(payload, brokerHost, dynamicAnalysisQueue);
    	return "OK";
    }
 
    @RequestMapping(value = "/static/send", 
    		        method= RequestMethod.POST, 
    		        consumes = {"application/JSON"})
    @ResponseBody
    public String sendStaticMessage(@RequestBody String payload) {
    	LOG.info("============= REST API /static/send/ triggered. Received payload: " + payload);
    	producer.sendMessage(payload, brokerHost, staticAnalysisQueue);
    	return "OK";
    }

    @RequestMapping(value = "/static/send", 
	        method= RequestMethod.POST, 
	        consumes = {"application/JSON"})
	@ResponseBody
	public String sendNsrlMessage(@RequestBody String payload) {
	LOG.info("============= REST API /nsrl/send/ triggered. Received payload: " + payload);
	producer.sendMessage(payload, brokerHost, nsrlQueue);
	return "OK";
	}
    
    @RequestMapping("/workflow/start")
    public void startWorkflow(String submissionReq) {
            initialize();
            listContainers();
            disposeContainer();
			//createContainer();
			//listProcesses();
           // showProfile(); 
			startProcess(submissionReq);		
    }

	public void initialize() {
        conf = KieServicesFactory.newRestConfiguration(URL, USER, PASSWORD);
        conf.setMarshallingFormat(FORMAT);
        kieServicesClient = KieServicesFactory.newKieServicesClient(conf);
	}
	
	
	public void listContainers() {
		System.out.println("== Listing containers ==");

		// Retrieve list of KIE containers
		kieContainers = kieServicesClient.listContainers().getResult().getContainers();
		for(KieContainerResource kList: kieContainers) {
			LOG.info(kList.getContainerId());
		}
		if (kieContainers.size() == 0) {
			LOG.info("No containers available...");
			return;
		}
	}

	public void disposeContainer() {
		LOG.info("== Disposing containers ==");

		// Dispose KIE container
		if (!kieContainers.isEmpty()) {
			container = kieContainers.get(0);
			containerId = container.getContainerId();
			responseDispose = kieServicesClient.disposeContainer(containerId);
			if (responseDispose.getType() == ResponseType.FAILURE) {
				System.out.println("Error disposing " + containerId + ". Message: ");
				System.out.println(responseDispose.getMsg());
				return;
			}
			System.out.println("Success Disposing container " + containerId);
			System.out.println("Trying to recreate the container..." + containerId);

		}
		else {
			LOG.info("No containers found. Moving on to next step.");
		}
		
	}

	public void createContainer() {
		System.out.println("== Creating container ==");
		// Re-create KIE container
		containerId = "malwareKContainer";
		//container = new KieContainerResource ();
		createResponse = kieServicesClient.createContainer(containerId, container);
		if(createResponse.getType() == ResponseType.FAILURE) {
			System.out.println("Error creating " + containerId + ". Message: ");
			System.out.println(createResponse.getMsg());
			return;
		}
		LOG.info("Container " + containerId + " recreated with success!");
    }
    
    
	public void listProcesses() {
		System.out.println("== Listing Business Processes for " + containerId + "==");
		QueryServicesClient queryClient = kieServicesClient.getServicesClient(QueryServicesClient.class);
		List<ProcessDefinition> findProcessesByContainerId = queryClient.findProcessesByContainerId(containerId, 0, 1000);
		for (ProcessDefinition def : findProcessesByContainerId) {
			LOG.info(def.getName() + " - " + def.getId() + " v" + def.getVersion());
		}
	}

	public void startProcess(String submissionReq) {
		//processId = "HelloWorld.HelloWorldWorkflow";
		LOG.info("== Starting process " + processId + " for container " + containerId + "==");	  
		// ProcessServicesClient setup
		ProcessServicesClient processServicesClient = kieServicesClient.getServicesClient(ProcessServicesClient.class);
	    
	    Map<String, Object> variables = new HashMap<String, Object>();
	    
	    
	     * reqPayload is the raw payload consumed from submission queue
	     
	    variables.put("reqPayload", submissionReq);

	    
	     * idGeneratorUrl is the micro-service api for generating unique id
	     
	    variables.put("idGeneratorUrl", idGeneratorUrl);

	    
	     * hashSeenUrl is the micro-service api for checking existing hash
	     
	    variables.put("hashSeenUrl", hashSeenUrl);
	    
	    
	     * submissionRecordUrl is the micro-service api for submitting to the dynamic queue
	     * submissionRecordReq is the request JSON payload
	     		    
	    variables.put("submissionRecordUrl", submissionRecordUrl);
	    //variables.put("submissionRecordReq", submissionRecordReq);

	    
	     * moveFileurl is the micro-service api for submitting to the dynamic queue
	     * moveFileReq is the request JSON payload
	     		    
	    variables.put("moveFileUrl", moveFileUrl);
	    //variables.put("moveFileReq", moveFileReq);
	 
	    
	     * create metadata is the micro-service api for creating hash for file
	     * createMetadaReq is the request JSON payload
	     		    
	    variables.put("createMetadataUrl", createMetadataUrl);
	    variables.put("createMetadataReq", createMetadataReq);
	    
	    
	     * nsrl lookup is the micro-service api for fetching nsrl report
	     * nsrlMetadataReq is the request for JSON payload
	     		    
	    variables.put("nsrlLookupUrl", nsrlLookupUrl);
	    variables.put("nsrlLookupReq", nsrlLookupReq);
	    
	    
	     * create transaction record is the micro-service api for creating metadata in the backend database
	     * createTransactionReq is the request for JSON payload
	     		    
	    variables.put("createTrecordUrl", createTransactionRecordUrl);
	    variables.put("createTrecordReq", createTransactionRecordReq);
	    
	    
	     * create transaction record is the micro-service api for creating metadata in the backend database
	     * createTransactionReq is the request for JSON payload
	     		    
	    variables.put("createTrecordUrl", createTransactionRecordUrl);
	    variables.put("createTrecordReq", createTransactionRecordReq);

	    
	     * hash file is the micro-service api for creating hash in the backend database
	     * createHashReq is the request for JSON payload
	     		    
	    variables.put("createHashUrl", createHashUrl);
	    variables.put("createHashReq", createHashReq);
	
	    
	     * hash file is the micro-service api for creating hash in the backend database
	     * createHashReq is the request for JSON payload
	     		    
	    variables.put("unzipUrl", unzipFileUrl);
	    variables.put("unzipReq", unzipFileReq);
	    
	    
	     * staticAnalysisUrl is the micro-service api for submitting to the static queue
	     	    
	    variables.put("staticAnalysisUrl", staticAnalysisUrl);
	    
	    
	     * dynamicAnalysisUrl is the micro-service api for submitting to the dynamic queue
	     		    
	    variables.put("dynamicAnalysisUrl", dynamicAnalysisUrl);
	    
	    
	     * dataServiceUrl is the micro-service for transforming the request payload for each core service
	     		    
	    variables.put("dataServiceUrl", dataServiceUrl);    
	    
	    LOG.info("Map Content  " + variables.toString());
	    
		// Start the process with
		processResult = processServicesClient.startProcess(containerId, processId, variables);
		LOG.info("Success starting " + processId + " instance " + processResult);

	  }*/

}