package com.malware;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.KieContainerResource;
import org.kie.server.api.model.KieServiceResponse.ResponseType;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.api.model.definition.ProcessDefinition;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.ProcessServicesClient;
import org.kie.server.client.QueryServicesClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ProxyController {

	//private static final String URL = "http://localhost:8080/kie-server/services/rest/server";
  	//private static final String USER = "kie-server";
	//private static final String PASSWORD = "kie-server";
	private static final Logger LOG = LoggerFactory.getLogger(ProxyController.class);
	
	@Value("${spring.pam.url}")
	private String URL;
	
	@Value("${spring.pam.user}")
  	private String USER;

	@Value("${spring.pam.password}")
	private String PASSWORD;
	
	@Value("${spring.process.id}")
	private String processId;
	
/*	@Value("${submissionRequest}")
	private String submissionRequest;*/
	
	@Value("${cuckooRequest}")
	private String cuckooRequest;

	@Value("${dynamic.analysis.url}")
	private String dynamicAnalysisUrl;
	
	@Value("${static.analysis.url}")
	private String staticAnalysisUrl;
		
	@Value("${id.generator.url}")
	private String idGeneratorUrl;
	
	@Value("${dynamic.analysis.queue}")
	private String dynamicAnalysisQueue;
	
	@Value("${static.analysis.queue}")
	private String staticAnalysisQueue;

	@Value("${amqphub.amqp10jms.remote-url}")
	private String brokerHost;
	
	@Value("${submission.record.url}")
	private String submissionRecordUrl;
	
	@Value("${submission.record.request}")
	private String submissionRecordReq;
	
	@Value("${move.file.url}")
	private String moveFileUrl;
		
	@Value("${move.file.request}")
	private String moveFileReq;	
	
	@Value("${create.metadata.url}")
	private String createMetadataUrl;
		
	@Value("${create.metadata.request}")
	private String createMetadataReq;	

	@Value("${nsrl.lookup.url}")
	private String nsrlLookupUrl;
		
	@Value("${nsrl.lookup.request}")
	private String nsrlLookupReq;	

	@Value("${create.trecord.url}")
	private String createTransactionRecordUrl;
		
	@Value("${create.trecord.request}")
	private String createTransactionRecordReq;	
	
	@Value("${create.hash.url}")
	private String createHashUrl;
		
	@Value("${create.hash.request}")
	private String createHashReq;	
	
	/*
	private static List <KieContainerResource> kieContainers;
	private static KieContainerResource container;
	private static String containerId;
	private static ServiceResponse<Void> responseDispose;
	private static ServiceResponse<KieContainerResource> createResponse;
	private static String processId;
	private static Long processResult;
	  
	private static final MarshallingFormat FORMAT = MarshallingFormat.JSON;

  	private static KieServicesConfiguration conf;
  	private static KieServicesClient kieServicesClient;
    */
	
	private List <KieContainerResource> kieContainers;
	private KieContainerResource container;
	private String containerId;
	private ServiceResponse<Void> responseDispose;
	private ServiceResponse<KieContainerResource> createResponse;
	//private String processId;
	private Long processResult;
	  
	private final MarshallingFormat FORMAT = MarshallingFormat.JSON;

  	private KieServicesConfiguration conf;
  	private KieServicesClient kieServicesClient;

  	@Autowired
  	private MessageProducer producer;

  	/*
  	 * Mock API below are for simplifying local testing 
  	 */
    @RequestMapping("/mock/generate_ids/1")
    @ResponseBody
	public String mockIdGen() {
		LOG.info("============= MOCKED REST API mock/generate_ids/1 triggered. ");
		return ("12345");
	}

    @RequestMapping("/mock/submissions")
    @ResponseBody
	public String mockFileSubmission() {
		LOG.info("============= MOCKED File Submission API mock/submission triggered. ");
		return ("Mocked File Submission Response");
	}

    @RequestMapping("/mock/move_files")
    @ResponseBody
	public String mockMoveFile() {
		LOG.info("============= MOCKED File Mover API mock/move_files triggered. ");
		return ("Mocked Move Files Response");
	}
    
    @RequestMapping("/mock/create_metadata")
    @ResponseBody
	public String mockCreateMetadata() {
		LOG.info("============= MOCKED Create Metadata API mock/create_metadata triggered. ");
		return ("Mocked Create Metadata Response");
	}
 
    @RequestMapping("/mock/nsrl_lookup")
    @ResponseBody
	public String mockNsrlLookup() {
		LOG.info("============= MOCKED NSRL Lookup API mock/nsrl_lookup triggered. ");
		return ("Mocked NSRL Lookup Response");
	}
    
    @RequestMapping("/mock/create_trecord")
    @ResponseBody
	public String mockCreateTransactionRecord() {
		LOG.info("============= MOCKED Create Transaction Record API mock/crate_trecord triggered. ");
		return ("Mocked Create Transactin Record Response");
	}
    
    @RequestMapping("/mock/create_hash")
    @ResponseBody
	public String mockHashFile() {
		LOG.info("============= MOCKED Create Hash API mock/create_hash triggered. ");
		return ("Mocked Create Hash Response");
	}
    
    @RequestMapping(value = "/dynamic/send", 
    		        method= RequestMethod.POST, 
    		        consumes = {"application/JSON"})
    @ResponseBody
    public String sendDynamicMessage(@RequestBody String payload) {
    	LOG.info("============= REST API /dynamic/send/ triggered. Received payload: " + payload);
    	producer.sendMessage(payload, brokerHost, dynamicAnalysisQueue);
    	return "OK";
    }
 
    @RequestMapping(value = "/static/send", 
    		        method= RequestMethod.POST, 
    		        consumes = {"application/JSON"})
    @ResponseBody
    public String sendStaticMessage(@RequestBody String payload) {
    	LOG.info("============= REST API /static/send/ triggered. Received payload: " + payload);
    	producer.sendMessage(payload, brokerHost, staticAnalysisQueue);
    	return "OK";
    }
    
    @RequestMapping("/workflow/start")
    public void startWorkflow(String submissionReq) {
            initialize();
            listContainers();
            disposeContainer();
			//createContainer();
			//listProcesses();
           // showProfile(); 
			startProcess(submissionReq);		
    }

	public void initialize() {
        conf = KieServicesFactory.newRestConfiguration(URL, USER, PASSWORD);
        conf.setMarshallingFormat(FORMAT);
        kieServicesClient = KieServicesFactory.newKieServicesClient(conf);
	}
	
	
	public void listContainers() {
		System.out.println("== Listing containers ==");

		// Retrieve list of KIE containers
		kieContainers = kieServicesClient.listContainers().getResult().getContainers();
		for(KieContainerResource kList: kieContainers) {
			LOG.info(kList.getContainerId());
		}
		if (kieContainers.size() == 0) {
			LOG.info("No containers available...");
			return;
		}
	}

	public void disposeContainer() {
		LOG.info("== Disposing containers ==");

		// Dispose KIE container
		if (!kieContainers.isEmpty()) {
			container = kieContainers.get(0);
			containerId = container.getContainerId();
			/*responseDispose = kieServicesClient.disposeContainer(containerId);
			if (responseDispose.getType() == ResponseType.FAILURE) {
				System.out.println("Error disposing " + containerId + ". Message: ");
				System.out.println(responseDispose.getMsg());
				return;
			}
			System.out.println("Success Disposing container " + containerId);
			System.out.println("Trying to recreate the container..." + containerId);*/

		}
		else {
			LOG.info("No containers found. Moving on to next step.");
		}
		
	}

	public void createContainer() {
		System.out.println("== Creating container ==");
		// Re-create KIE container
		containerId = "malwareKContainer";
		//container = new KieContainerResource ();
		createResponse = kieServicesClient.createContainer(containerId, container);
		if(createResponse.getType() == ResponseType.FAILURE) {
			System.out.println("Error creating " + containerId + ". Message: ");
			System.out.println(createResponse.getMsg());
			return;
		}
		LOG.info("Container " + containerId + " recreated with success!");
    }
    
    
	public void listProcesses() {
		System.out.println("== Listing Business Processes for " + containerId + "==");
		QueryServicesClient queryClient = kieServicesClient.getServicesClient(QueryServicesClient.class);
		List<ProcessDefinition> findProcessesByContainerId = queryClient.findProcessesByContainerId(containerId, 0, 1000);
		for (ProcessDefinition def : findProcessesByContainerId) {
			LOG.info(def.getName() + " - " + def.getId() + " v" + def.getVersion());
		}
	}

	public void startProcess(String submissionReq) {
		//processId = "HelloWorld.HelloWorldWorkflow";
		LOG.info("== Starting process " + processId + " for container " + containerId + "==");	  
		// ProcessServicesClient setup
		ProcessServicesClient processServicesClient = kieServicesClient.getServicesClient(ProcessServicesClient.class);
	    
	    Map<String, Object> variables = new HashMap<String, Object>();
	    
	    /*
	     * reqPayload is the raw payload consumed from submission queue
	     */
	    variables.put("reqPayload", submissionReq);

	    /*
	     * idGeneratorUrl is the micro-service api for generating unique id
	     */
	    variables.put("idGeneratorUrl", idGeneratorUrl);

	    /*
	     * submissionRecordUrl is the micro-service api for submitting to the dynamic queue
	     * submissionRecordReq is the request JSON payload
	     */		    
	    variables.put("submissionRecordUrl", submissionRecordUrl);
	    variables.put("submissionRecordReq", submissionRecordReq);

	    /*
	     * moveFileurl is the micro-service api for submitting to the dynamic queue
	     * moveFileReq is the request JSON payload
	     */		    
	    variables.put("moveFileUrl", moveFileUrl);
	    variables.put("moveFileReq", moveFileReq);
	 
	    /*
	     * create metadata is the micro-service api for creating hash for file
	     * createMetadaReq is the request JSON payload
	     */		    
	    variables.put("createMetadataUrl", createMetadataUrl);
	    variables.put("createMetadataReq", createMetadataReq);
	    
	    /*
	     * nsrl lookup is the micro-service api for fetching nsrl report
	     * nsrlMetadataReq is the request for JSON payload
	     */		    
	    variables.put("nsrlLookupUrl", nsrlLookupUrl);
	    variables.put("nsrlLookupReq", nsrlLookupReq);
	    
	    /*
	     * create transaction record is the micro-service api for creating metadata in the backend database
	     * createTransactionReq is the request for JSON payload
	     */		    
	    variables.put("createTrecordUrl", createTransactionRecordUrl);
	    variables.put("createTrecordReq", createTransactionRecordReq);
	    
	    /*
	     * create transaction record is the micro-service api for creating metadata in the backend database
	     * createTransactionReq is the request for JSON payload
	     */		    
	    variables.put("createTrecordUrl", createTransactionRecordUrl);
	    variables.put("createTrecordReq", createTransactionRecordReq);

	    /*
	     * hash file is the micro-service api for creating hash in the backend database
	     * createHashReq is the request for JSON payload
	     */		    
	    variables.put("createHashUrl", createHashUrl);
	    variables.put("createHashReq", createHashReq);
	    
	    /*
	     * staticAnalysisUrl is the micro-service api for submitting to the static queue
	     */	    
	    variables.put("staticAnalysisUrl", staticAnalysisUrl);
	    
	    /*
	     * dynamicAnalysisUrl is the micro-service api for submitting to the dynamic queue
	     */		    
	    variables.put("dynamicAnalysisUrl", dynamicAnalysisUrl);
	    
	    LOG.info("Map Content  " + variables.toString());
	    
		// Start the process with
		processResult = processServicesClient.startProcess(containerId, processId, variables);
		LOG.info("Success starting " + processId + " instance " + processResult);

	  }

}